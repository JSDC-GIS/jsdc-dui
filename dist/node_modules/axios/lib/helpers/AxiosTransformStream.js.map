{"version":3,"file":"AxiosTransformStream.js","sources":["../../../../../node_modules/axios/lib/helpers/AxiosTransformStream.js"],"sourcesContent":["'use strict';\n\nimport stream from 'stream';\nimport utils from '../utils.js';\n\nconst kInternals = Symbol('internals');\n\nclass AxiosTransformStream extends stream.Transform{\n  constructor(options) {\n    options = utils.toFlatObject(options, {\n      maxRate: 0,\n      chunkSize: 64 * 1024,\n      minChunkSize: 100,\n      timeWindow: 500,\n      ticksRate: 2,\n      samplesCount: 15\n    }, null, (prop, source) => {\n      return !utils.isUndefined(source[prop]);\n    });\n\n    super({\n      readableHighWaterMark: options.chunkSize\n    });\n\n    const internals = this[kInternals] = {\n      timeWindow: options.timeWindow,\n      chunkSize: options.chunkSize,\n      maxRate: options.maxRate,\n      minChunkSize: options.minChunkSize,\n      bytesSeen: 0,\n      isCaptured: false,\n      notifiedBytesLoaded: 0,\n      ts: Date.now(),\n      bytes: 0,\n      onReadCallback: null\n    };\n\n    this.on('newListener', event => {\n      if (event === 'progress') {\n        if (!internals.isCaptured) {\n          internals.isCaptured = true;\n        }\n      }\n    });\n  }\n\n  _read(size) {\n    const internals = this[kInternals];\n\n    if (internals.onReadCallback) {\n      internals.onReadCallback();\n    }\n\n    return super._read(size);\n  }\n\n  _transform(chunk, encoding, callback) {\n    const internals = this[kInternals];\n    const maxRate = internals.maxRate;\n\n    const readableHighWaterMark = this.readableHighWaterMark;\n\n    const timeWindow = internals.timeWindow;\n\n    const divider = 1000 / timeWindow;\n    const bytesThreshold = (maxRate / divider);\n    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;\n\n    const pushChunk = (_chunk, _callback) => {\n      const bytes = Buffer.byteLength(_chunk);\n      internals.bytesSeen += bytes;\n      internals.bytes += bytes;\n\n      internals.isCaptured && this.emit('progress', internals.bytesSeen);\n\n      if (this.push(_chunk)) {\n        process.nextTick(_callback);\n      } else {\n        internals.onReadCallback = () => {\n          internals.onReadCallback = null;\n          process.nextTick(_callback);\n        };\n      }\n    }\n\n    const transformChunk = (_chunk, _callback) => {\n      const chunkSize = Buffer.byteLength(_chunk);\n      let chunkRemainder = null;\n      let maxChunkSize = readableHighWaterMark;\n      let bytesLeft;\n      let passed = 0;\n\n      if (maxRate) {\n        const now = Date.now();\n\n        if (!internals.ts || (passed = (now - internals.ts)) >= timeWindow) {\n          internals.ts = now;\n          bytesLeft = bytesThreshold - internals.bytes;\n          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;\n          passed = 0;\n        }\n\n        bytesLeft = bytesThreshold - internals.bytes;\n      }\n\n      if (maxRate) {\n        if (bytesLeft <= 0) {\n          // next time window\n          return setTimeout(() => {\n            _callback(null, _chunk);\n          }, timeWindow - passed);\n        }\n\n        if (bytesLeft < maxChunkSize) {\n          maxChunkSize = bytesLeft;\n        }\n      }\n\n      if (maxChunkSize && chunkSize > maxChunkSize && (chunkSize - maxChunkSize) > minChunkSize) {\n        chunkRemainder = _chunk.subarray(maxChunkSize);\n        _chunk = _chunk.subarray(0, maxChunkSize);\n      }\n\n      pushChunk(_chunk, chunkRemainder ? () => {\n        process.nextTick(_callback, null, chunkRemainder);\n      } : _callback);\n    };\n\n    transformChunk(chunk, function transformNextChunk(err, _chunk) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (_chunk) {\n        transformChunk(_chunk, transformNextChunk);\n      } else {\n        callback(null);\n      }\n    });\n  }\n}\n\nexport default AxiosTransformStream;\n"],"names":["kInternals","Symbol","AxiosTransformStream","stream","Transform","constructor","options","super","readableHighWaterMark","utils","toFlatObject","maxRate","chunkSize","minChunkSize","timeWindow","ticksRate","samplesCount","prop","source","isUndefined","internals","this","bytesSeen","isCaptured","notifiedBytesLoaded","ts","Date","now","bytes","onReadCallback","on","event","_read","size","_transform","chunk","encoding","callback","bytesThreshold","Math","max","pushChunk","_chunk","_callback","Buffer","byteLength","emit","push","process","nextTick","transformChunk","bytesLeft","chunkRemainder","maxChunkSize","passed","setTimeout","subarray","transformNextChunk","err","AxiosTransformStream$1"],"mappings":"iDAKA,MAAMA,EAAaC,OAAO,aAE1B,MAAMC,UAA6BC,EAAOC,UACxCC,YAAYC,GAYVC,MAAM,CACJC,uBAZFF,EAAUG,EAAMC,aAAaJ,EAAS,CACpCK,QAAS,EACTC,UAAW,MACXC,aAAc,IACdC,WAAY,IACZC,UAAW,EACXC,aAAc,IACb,MAAM,CAACC,EAAMC,KACNT,EAAMU,YAAYD,EAAOD,OAIFL,YAGjC,MAAMQ,EAAYC,KAAKrB,GAAc,CACnCc,WAAYR,EAAQQ,WACpBF,UAAWN,EAAQM,UACnBD,QAASL,EAAQK,QACjBE,aAAcP,EAAQO,aACtBS,UAAW,EACXC,YAAY,EACZC,oBAAqB,EACrBC,GAAIC,KAAKC,MACTC,MAAO,EACPC,eAAgB,MAGlBR,KAAKS,GAAG,eAAeC,IACP,aAAVA,IACGX,EAAUG,aACbH,EAAUG,YAAa,OAM/BS,MAAMC,GACJ,MAAMb,EAAYC,KAAKrB,GAMvB,OAJIoB,EAAUS,gBACZT,EAAUS,iBAGLtB,MAAMyB,MAAMC,GAGrBC,WAAWC,EAAOC,EAAUC,GAC1B,MAAMjB,EAAYC,KAAKrB,GACjBW,EAAUS,EAAUT,QAEpBH,EAAwBa,KAAKb,sBAE7BM,EAAaM,EAAUN,WAGvBwB,EAAkB3B,GADR,IAAOG,GAEjBD,GAA0C,IAA3BO,EAAUP,aAAyB0B,KAAKC,IAAIpB,EAAUP,aAA+B,IAAjByB,GAAyB,EAE5GG,EAAY,CAACC,EAAQC,KACzB,MAAMf,EAAQgB,OAAOC,WAAWH,GAChCtB,EAAUE,WAAaM,EACvBR,EAAUQ,OAASA,EAEnBR,EAAUG,YAAcF,KAAKyB,KAAK,WAAY1B,EAAUE,WAEpDD,KAAK0B,KAAKL,GACZM,QAAQC,SAASN,GAEjBvB,EAAUS,eAAiB,KACzBT,EAAUS,eAAiB,KAC3BmB,QAAQC,SAASN,KAKjBO,EAAiB,CAACR,EAAQC,KAC9B,MAAM/B,EAAYgC,OAAOC,WAAWH,GACpC,IAEIS,EAFAC,EAAiB,KACjBC,EAAe7C,EAEf8C,EAAS,EAEb,GAAI3C,EAAS,CACX,MAAMgB,EAAMD,KAAKC,QAEZP,EAAUK,KAAO6B,EAAU3B,EAAMP,EAAUK,KAAQX,KACtDM,EAAUK,GAAKE,EACfwB,EAAYb,EAAiBlB,EAAUQ,MACvCR,EAAUQ,MAAQuB,EAAY,GAAKA,EAAY,EAC/CG,EAAS,GAGXH,EAAYb,EAAiBlB,EAAUQ,MAGzC,GAAIjB,EAAS,CACX,GAAIwC,GAAa,EAEf,OAAOI,YAAW,KAChBZ,EAAU,KAAMD,KACf5B,EAAawC,GAGdH,EAAYE,IACdA,EAAeF,GAIfE,GAAgBzC,EAAYyC,GAAiBzC,EAAYyC,EAAgBxC,IAC3EuC,EAAiBV,EAAOc,SAASH,GACjCX,EAASA,EAAOc,SAAS,EAAGH,IAG9BZ,EAAUC,EAAQU,EAAiB,KACjCJ,QAAQC,SAASN,EAAW,KAAMS,IAChCT,IAGNO,EAAef,GAAO,SAASsB,EAAmBC,EAAKhB,GACrD,GAAIgB,EACF,OAAOrB,EAASqB,GAGdhB,EACFQ,EAAeR,EAAQe,GAEvBpB,EAAS,UAMjB,IAAAsB,EAAezD"}