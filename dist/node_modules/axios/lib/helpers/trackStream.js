const e=function*(e,t){let n=e.byteLength;if(!t||n<t)return void(yield e);let a,r=0;for(;r<n;)a=r+t,yield e.slice(r,a),r=a},t=async function*(t,a){for await(const r of n(t))yield*e(r,a)},n=async function*(e){if(e[Symbol.asyncIterator])return void(yield*e);const t=e.getReader();try{for(;;){const{done:e,value:n}=await t.read();if(e)break;yield n}}finally{await t.cancel()}},a=(e,n,a,r)=>{const i=t(e,n);let o,l=0,c=e=>{o||(o=!0,r&&r(e))};return new ReadableStream({async pull(e){try{const{done:t,value:n}=await i.next();if(t)return c(),void e.close();let r=n.byteLength;if(a){let e=l+=r;a(e)}e.enqueue(new Uint8Array(n))}catch(e){throw c(e),e}},cancel:e=>(c(e),i.return())},{highWaterMark:2})};export{t as readBytes,e as streamChunk,a as trackStream};
//# sourceMappingURL=trackStream.js.map
