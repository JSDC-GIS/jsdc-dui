{"version":3,"file":"estimateDataURLDecodedBytes.js","sources":["../../../../../node_modules/axios/lib/helpers/estimateDataURLDecodedBytes.js"],"sourcesContent":["/**\n * Estimate decoded byte length of a data:// URL *without* allocating large buffers.\n * - For base64: compute exact decoded size using length and padding;\n *               handle %XX at the character-count level (no string allocation).\n * - For non-base64: use UTF-8 byteLength of the encoded body as a safe upper bound.\n *\n * @param {string} url\n * @returns {number}\n */\nexport default function estimateDataURLDecodedBytes(url) {\n  if (!url || typeof url !== 'string') return 0;\n  if (!url.startsWith('data:')) return 0;\n\n  const comma = url.indexOf(',');\n  if (comma < 0) return 0;\n\n  const meta = url.slice(5, comma);\n  const body = url.slice(comma + 1);\n  const isBase64 = /;base64/i.test(meta);\n\n  if (isBase64) {\n    let effectiveLen = body.length;\n    const len = body.length; // cache length\n\n    for (let i = 0; i < len; i++) {\n      if (body.charCodeAt(i) === 37 /* '%' */ && i + 2 < len) {\n        const a = body.charCodeAt(i + 1);\n        const b = body.charCodeAt(i + 2);\n        const isHex =\n          ((a >= 48 && a <= 57) || (a >= 65 && a <= 70) || (a >= 97 && a <= 102)) &&\n          ((b >= 48 && b <= 57) || (b >= 65 && b <= 70) || (b >= 97 && b <= 102));\n\n        if (isHex) {\n          effectiveLen -= 2;\n          i += 2;\n        }\n      }\n    }\n\n    let pad = 0;\n    let idx = len - 1;\n\n    const tailIsPct3D = (j) =>\n      j >= 2 &&\n      body.charCodeAt(j - 2) === 37 && // '%'\n      body.charCodeAt(j - 1) === 51 && // '3'\n      (body.charCodeAt(j) === 68 || body.charCodeAt(j) === 100); // 'D' or 'd'\n\n    if (idx >= 0) {\n      if (body.charCodeAt(idx) === 61 /* '=' */) {\n        pad++;\n        idx--;\n      } else if (tailIsPct3D(idx)) {\n        pad++;\n        idx -= 3;\n      }\n    }\n\n    if (pad === 1 && idx >= 0) {\n      if (body.charCodeAt(idx) === 61 /* '=' */) {\n        pad++;\n      } else if (tailIsPct3D(idx)) {\n        pad++;\n      }\n    }\n\n    const groups = Math.floor(effectiveLen / 4);\n    const bytes = groups * 3 - (pad || 0);\n    return bytes > 0 ? bytes : 0;\n  }\n\n  return Buffer.byteLength(body, 'utf8');\n}\n"],"names":["estimateDataURLDecodedBytes","url","startsWith","comma","indexOf","meta","slice","body","test","effectiveLen","length","len","i","charCodeAt","a","b","pad","idx","tailIsPct3D","j","bytes","Math","floor","Buffer","byteLength"],"mappings":"AASe,SAASA,EAA4BC,GAClD,IAAKA,GAAsB,iBAARA,EAAkB,OAAO,EAC5C,IAAKA,EAAIC,WAAW,SAAU,OAAO,EAErC,MAAMC,EAAQF,EAAIG,QAAQ,KAC1B,GAAID,EAAQ,EAAG,OAAO,EAEtB,MAAME,EAAOJ,EAAIK,MAAM,EAAGH,GACpBI,EAAON,EAAIK,MAAMH,EAAQ,GAG/B,GAFiB,WAAWK,KAAKH,GAEnB,CACZ,IAAII,EAAeF,EAAKG,OACxB,MAAMC,EAAMJ,EAAKG,OAEjB,IAAK,IAAIE,EAAI,EAAGA,EAAID,EAAKC,IACvB,GAA2B,KAAvBL,EAAKM,WAAWD,IAAuBA,EAAI,EAAID,EAAK,CACtD,MAAMG,EAAIP,EAAKM,WAAWD,EAAI,GACxBG,EAAIR,EAAKM,WAAWD,EAAI,IAE1BE,GAAK,IAAMA,GAAK,IAAQA,GAAK,IAAMA,GAAK,IAAQA,GAAK,IAAMA,GAAK,OAChEC,GAAK,IAAMA,GAAK,IAAQA,GAAK,IAAMA,GAAK,IAAQA,GAAK,IAAMA,GAAK,OAGlEN,GAAgB,EAChBG,GAAK,GAKX,IAAII,EAAM,EACNC,EAAMN,EAAM,EAEhB,MAAMO,EAAeC,GACnBA,GAAK,GACsB,KAA3BZ,EAAKM,WAAWM,EAAI,IACO,KAA3BZ,EAAKM,WAAWM,EAAI,KACI,KAAvBZ,EAAKM,WAAWM,IAAoC,MAAvBZ,EAAKM,WAAWM,IAE5CF,GAAO,IACoB,KAAzBV,EAAKM,WAAWI,IAClBD,IACAC,KACSC,EAAYD,KACrBD,IACAC,GAAO,IAIC,IAARD,GAAaC,GAAO,IACO,KAAzBV,EAAKM,WAAWI,IAETC,EAAYD,KADrBD,IAMJ,MACMI,EAAiB,EADRC,KAAKC,MAAMb,EAAe,IACbO,GAAO,GACnC,OAAOI,EAAQ,EAAIA,EAAQ,EAG7B,OAAOG,OAAOC,WAAWjB,EAAM"}