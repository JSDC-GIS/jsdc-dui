import{VERSION as n}from"../env/data.js";import o from"../core/AxiosError.js";const e={};["object","boolean","number","function","string","symbol"].forEach(((n,o)=>{e[n]=function(e){return typeof e===n||"a"+(o<1?"n ":" ")+n}}));const t={};e.transitional=function(e,r,i){function s(o,e){return"[Axios v"+n+"] Transitional option '"+o+"'"+e+(i?". "+i:"")}return(n,i,a)=>{if(!1===e)throw new o(s(i," has been removed"+(r?" in "+r:"")),o.ERR_DEPRECATED);return r&&!t[i]&&(t[i]=!0,console.warn(s(i," has been deprecated since v"+r+" and will be removed in the near future"))),!e||e(n,i,a)}},e.spelling=function(n){return(o,e)=>(console.warn(`${e} is likely a misspelling of ${n}`),!0)};var r={assertOptions:function(n,e,t){if("object"!=typeof n)throw new o("options must be an object",o.ERR_BAD_OPTION_VALUE);const r=Object.keys(n);let i=r.length;for(;i-- >0;){const s=r[i],a=e[s];if(a){const e=n[s],t=void 0===e||a(e,s,n);if(!0!==t)throw new o("option "+s+" must be "+t,o.ERR_BAD_OPTION_VALUE)}else if(!0!==t)throw new o("Unknown option "+s,o.ERR_BAD_OPTION)}},validators:e};export{r as default};
//# sourceMappingURL=validator.js.map
