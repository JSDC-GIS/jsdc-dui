{"version":3,"file":"fetch.js","sources":["../../../../../node_modules/axios/lib/adapters/fetch.js"],"sourcesContent":["import platform from \"../platform/index.js\";\nimport utils from \"../utils.js\";\nimport AxiosError from \"../core/AxiosError.js\";\nimport composeSignals from \"../helpers/composeSignals.js\";\nimport {trackStream} from \"../helpers/trackStream.js\";\nimport AxiosHeaders from \"../core/AxiosHeaders.js\";\nimport {progressEventReducer, progressEventDecorator, asyncDecorator} from \"../helpers/progressEventReducer.js\";\nimport resolveConfig from \"../helpers/resolveConfig.js\";\nimport settle from \"../core/settle.js\";\n\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\n\nconst {isFunction} = utils;\n\nconst globalFetchAPI = (({Request, Response}) => ({\n  Request, Response\n}))(utils.global);\n\nconst {\n  ReadableStream, TextEncoder\n} = utils.global;\n\n\nconst test = (fn, ...args) => {\n  try {\n    return !!fn(...args);\n  } catch (e) {\n    return false\n  }\n}\n\nconst factory = (env) => {\n  env = utils.merge.call({\n    skipUndefined: true\n  }, globalFetchAPI, env);\n\n  const {fetch: envFetch, Request, Response} = env;\n  const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === 'function';\n  const isRequestSupported = isFunction(Request);\n  const isResponseSupported = isFunction(Response);\n\n  if (!isFetchSupported) {\n    return false;\n  }\n\n  const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream);\n\n  const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?\n      ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :\n      async (str) => new Uint8Array(await new Request(str).arrayBuffer())\n  );\n\n  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {\n    let duplexAccessed = false;\n\n    const hasContentType = new Request(platform.origin, {\n      body: new ReadableStream(),\n      method: 'POST',\n      get duplex() {\n        duplexAccessed = true;\n        return 'half';\n      },\n    }).headers.has('Content-Type');\n\n    return duplexAccessed && !hasContentType;\n  });\n\n  const supportsResponseStream = isResponseSupported && isReadableStreamSupported &&\n    test(() => utils.isReadableStream(new Response('').body));\n\n  const resolvers = {\n    stream: supportsResponseStream && ((res) => res.body)\n  };\n\n  isFetchSupported && ((() => {\n    ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {\n      !resolvers[type] && (resolvers[type] = (res, config) => {\n        let method = res && res[type];\n\n        if (method) {\n          return method.call(res);\n        }\n\n        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);\n      })\n    });\n  })());\n\n  const getBodyLength = async (body) => {\n    if (body == null) {\n      return 0;\n    }\n\n    if (utils.isBlob(body)) {\n      return body.size;\n    }\n\n    if (utils.isSpecCompliantForm(body)) {\n      const _request = new Request(platform.origin, {\n        method: 'POST',\n        body,\n      });\n      return (await _request.arrayBuffer()).byteLength;\n    }\n\n    if (utils.isArrayBufferView(body) || utils.isArrayBuffer(body)) {\n      return body.byteLength;\n    }\n\n    if (utils.isURLSearchParams(body)) {\n      body = body + '';\n    }\n\n    if (utils.isString(body)) {\n      return (await encodeText(body)).byteLength;\n    }\n  }\n\n  const resolveBodyLength = async (headers, body) => {\n    const length = utils.toFiniteNumber(headers.getContentLength());\n\n    return length == null ? getBodyLength(body) : length;\n  }\n\n  return async (config) => {\n    let {\n      url,\n      method,\n      data,\n      signal,\n      cancelToken,\n      timeout,\n      onDownloadProgress,\n      onUploadProgress,\n      responseType,\n      headers,\n      withCredentials = 'same-origin',\n      fetchOptions\n    } = resolveConfig(config);\n\n    let _fetch = envFetch || fetch;\n\n    responseType = responseType ? (responseType + '').toLowerCase() : 'text';\n\n    let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);\n\n    let request = null;\n\n    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {\n      composedSignal.unsubscribe();\n    });\n\n    let requestContentLength;\n\n    try {\n      if (\n        onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&\n        (requestContentLength = await resolveBodyLength(headers, data)) !== 0\n      ) {\n        let _request = new Request(url, {\n          method: 'POST',\n          body: data,\n          duplex: \"half\"\n        });\n\n        let contentTypeHeader;\n\n        if (utils.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\n          headers.setContentType(contentTypeHeader)\n        }\n\n        if (_request.body) {\n          const [onProgress, flush] = progressEventDecorator(\n            requestContentLength,\n            progressEventReducer(asyncDecorator(onUploadProgress))\n          );\n\n          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);\n        }\n      }\n\n      if (!utils.isString(withCredentials)) {\n        withCredentials = withCredentials ? 'include' : 'omit';\n      }\n\n      // Cloudflare Workers throws when credentials are defined\n      // see https://github.com/cloudflare/workerd/issues/902\n      const isCredentialsSupported = isRequestSupported && \"credentials\" in Request.prototype;\n\n      const resolvedOptions = {\n        ...fetchOptions,\n        signal: composedSignal,\n        method: method.toUpperCase(),\n        headers: headers.normalize().toJSON(),\n        body: data,\n        duplex: \"half\",\n        credentials: isCredentialsSupported ? withCredentials : undefined\n      };\n\n      request = isRequestSupported && new Request(url, resolvedOptions);\n\n      let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));\n\n      const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\n\n      if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {\n        const options = {};\n\n        ['status', 'statusText', 'headers'].forEach(prop => {\n          options[prop] = response[prop];\n        });\n\n        const responseContentLength = utils.toFiniteNumber(response.headers.get('content-length'));\n\n        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(\n          responseContentLength,\n          progressEventReducer(asyncDecorator(onDownloadProgress), true)\n        ) || [];\n\n        response = new Response(\n          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {\n            flush && flush();\n            unsubscribe && unsubscribe();\n          }),\n          options\n        );\n      }\n\n      responseType = responseType || 'text';\n\n      let responseData = await resolvers[utils.findKey(resolvers, responseType) || 'text'](response, config);\n\n      !isStreamResponse && unsubscribe && unsubscribe();\n\n      return await new Promise((resolve, reject) => {\n        settle(resolve, reject, {\n          data: responseData,\n          headers: AxiosHeaders.from(response.headers),\n          status: response.status,\n          statusText: response.statusText,\n          config,\n          request\n        })\n      })\n    } catch (err) {\n      unsubscribe && unsubscribe();\n\n      if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {\n        throw Object.assign(\n          new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),\n          {\n            cause: err.cause || err\n          }\n        )\n      }\n\n      throw AxiosError.from(err, err && err.code, config, request);\n    }\n  }\n}\n\nconst seedCache = new Map();\n\nexport const getFetch = (config) => {\n  let env = config ? config.env : {};\n  const {fetch, Request, Response} = env;\n  const seeds = [\n    Request, Response, fetch\n  ];\n\n  let len = seeds.length, i = len,\n    seed, target, map = seedCache;\n\n  while (i--) {\n    seed = seeds[i];\n    target = map.get(seed);\n\n    target === undefined && map.set(seed, target = (i ? new Map() : factory(env)))\n\n    map = target;\n  }\n\n  return target;\n};\n\nconst adapter = getFetch();\n\nexport default adapter;\n"],"names":["isFunction","utils","globalFetchAPI","Request","Response","global","ReadableStream","TextEncoder","test","fn","args","e","factory","env","merge","call","skipUndefined","fetch","envFetch","isFetchSupported","isRequestSupported","isResponseSupported","isReadableStreamSupported","encodeText","encoder","str","encode","async","Uint8Array","arrayBuffer","supportsRequestStream","duplexAccessed","hasContentType","platform","origin","body","method","duplex","headers","has","supportsResponseStream","isReadableStream","resolvers","stream","res","forEach","type","config","AxiosError","ERR_NOT_SUPPORT","resolveBodyLength","length","toFiniteNumber","getContentLength","isBlob","size","isSpecCompliantForm","_request","byteLength","isArrayBufferView","isArrayBuffer","isURLSearchParams","isString","getBodyLength","url","data","signal","cancelToken","timeout","onDownloadProgress","onUploadProgress","responseType","withCredentials","fetchOptions","resolveConfig","_fetch","toLowerCase","composedSignal","composeSignals","toAbortSignal","request","unsubscribe","requestContentLength","contentTypeHeader","isFormData","get","setContentType","onProgress","flush","progressEventDecorator","progressEventReducer","asyncDecorator","trackStream","isCredentialsSupported","prototype","resolvedOptions","toUpperCase","normalize","toJSON","credentials","undefined","response","isStreamResponse","options","prop","responseContentLength","responseData","findKey","Promise","resolve","reject","settle","AxiosHeaders","from","status","statusText","err","name","message","Object","assign","ERR_NETWORK","cause","code","seedCache","Map","getFetch","seeds","seed","target","i","map","set"],"mappings":"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"}