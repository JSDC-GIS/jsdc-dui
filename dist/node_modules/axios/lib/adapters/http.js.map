{"version":3,"file":"http.js","sources":["../../../../../node_modules/axios/lib/adapters/http.js"],"sourcesContent":["'use strict';\n\nimport utils from './../utils.js';\nimport settle from './../core/settle.js';\nimport buildFullPath from '../core/buildFullPath.js';\nimport buildURL from './../helpers/buildURL.js';\nimport proxyFromEnv from 'proxy-from-env';\nimport http from 'http';\nimport https from 'https';\nimport util from 'util';\nimport followRedirects from 'follow-redirects';\nimport zlib from 'zlib';\nimport {VERSION} from '../env/data.js';\nimport transitionalDefaults from '../defaults/transitional.js';\nimport AxiosError from '../core/AxiosError.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport platform from '../platform/index.js';\nimport fromDataURI from '../helpers/fromDataURI.js';\nimport stream from 'stream';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport AxiosTransformStream from '../helpers/AxiosTransformStream.js';\nimport {EventEmitter} from 'events';\nimport formDataToStream from \"../helpers/formDataToStream.js\";\nimport readBlob from \"../helpers/readBlob.js\";\nimport ZlibHeaderTransformStream from '../helpers/ZlibHeaderTransformStream.js';\nimport callbackify from \"../helpers/callbackify.js\";\nimport {progressEventReducer, progressEventDecorator, asyncDecorator} from \"../helpers/progressEventReducer.js\";\nimport estimateDataURLDecodedBytes from '../helpers/estimateDataURLDecodedBytes.js';\n\nconst zlibOptions = {\n  flush: zlib.constants.Z_SYNC_FLUSH,\n  finishFlush: zlib.constants.Z_SYNC_FLUSH\n};\n\nconst brotliOptions = {\n  flush: zlib.constants.BROTLI_OPERATION_FLUSH,\n  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH\n}\n\nconst isBrotliSupported = utils.isFunction(zlib.createBrotliDecompress);\n\nconst {http: httpFollow, https: httpsFollow} = followRedirects;\n\nconst isHttps = /https:?/;\n\nconst supportedProtocols = platform.protocols.map(protocol => {\n  return protocol + ':';\n});\n\n\nconst flushOnFinish = (stream, [throttled, flush]) => {\n  stream\n    .on('end', flush)\n    .on('error', flush);\n\n  return throttled;\n}\n\n\n/**\n * If the proxy or config beforeRedirects functions are defined, call them with the options\n * object.\n *\n * @param {Object<string, any>} options - The options object that was passed to the request.\n *\n * @returns {Object<string, any>}\n */\nfunction dispatchBeforeRedirect(options, responseDetails) {\n  if (options.beforeRedirects.proxy) {\n    options.beforeRedirects.proxy(options);\n  }\n  if (options.beforeRedirects.config) {\n    options.beforeRedirects.config(options, responseDetails);\n  }\n}\n\n/**\n * If the proxy or config afterRedirects functions are defined, call them with the options\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} configProxy configuration from Axios options object\n * @param {string} location\n *\n * @returns {http.ClientRequestArgs}\n */\nfunction setProxy(options, configProxy, location) {\n  let proxy = configProxy;\n  if (!proxy && proxy !== false) {\n    const proxyUrl = proxyFromEnv.getProxyForUrl(location);\n    if (proxyUrl) {\n      proxy = new URL(proxyUrl);\n    }\n  }\n  if (proxy) {\n    // Basic proxy authorization\n    if (proxy.username) {\n      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');\n    }\n\n    if (proxy.auth) {\n      // Support proxy auth object form\n      if (proxy.auth.username || proxy.auth.password) {\n        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');\n      }\n      const base64 = Buffer\n        .from(proxy.auth, 'utf8')\n        .toString('base64');\n      options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n    }\n\n    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');\n    const proxyHost = proxy.hostname || proxy.host;\n    options.hostname = proxyHost;\n    // Replace 'host' since options is not a URL object\n    options.host = proxyHost;\n    options.port = proxy.port;\n    options.path = location;\n    if (proxy.protocol) {\n      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;\n    }\n  }\n\n  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {\n    // Configure proxy for redirected request, passing the original config proxy to apply\n    // the exact same logic as if the redirected request was performed by axios directly.\n    setProxy(redirectOptions, configProxy, redirectOptions.href);\n  };\n}\n\nconst isHttpAdapterSupported = typeof process !== 'undefined' && utils.kindOf(process) === 'process';\n\n// temporary hotfix\n\nconst wrapAsync = (asyncExecutor) => {\n  return new Promise((resolve, reject) => {\n    let onDone;\n    let isDone;\n\n    const done = (value, isRejected) => {\n      if (isDone) return;\n      isDone = true;\n      onDone && onDone(value, isRejected);\n    }\n\n    const _resolve = (value) => {\n      done(value);\n      resolve(value);\n    };\n\n    const _reject = (reason) => {\n      done(reason, true);\n      reject(reason);\n    }\n\n    asyncExecutor(_resolve, _reject, (onDoneHandler) => (onDone = onDoneHandler)).catch(_reject);\n  })\n};\n\nconst resolveFamily = ({address, family}) => {\n  if (!utils.isString(address)) {\n    throw TypeError('address must be a string');\n  }\n  return ({\n    address,\n    family: family || (address.indexOf('.') < 0 ? 6 : 4)\n  });\n}\n\nconst buildAddressEntry = (address, family) => resolveFamily(utils.isObject(address) ? address : {address, family});\n\n/*eslint consistent-return:0*/\nexport default isHttpAdapterSupported && function httpAdapter(config) {\n  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {\n    let {data, lookup, family} = config;\n    const {responseType, responseEncoding} = config;\n    const method = config.method.toUpperCase();\n    let isDone;\n    let rejected = false;\n    let req;\n\n    if (lookup) {\n      const _lookup = callbackify(lookup, (value) => utils.isArray(value) ? value : [value]);\n      // hotfix to support opt.all option which is required for node 20.x\n      lookup = (hostname, opt, cb) => {\n        _lookup(hostname, opt, (err, arg0, arg1) => {\n          if (err) {\n            return cb(err);\n          }\n\n          const addresses = utils.isArray(arg0) ? arg0.map(addr => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];\n\n          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);\n        });\n      }\n    }\n\n    // temporary internal emitter until the AxiosRequest class will be implemented\n    const emitter = new EventEmitter();\n\n    const onFinished = () => {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(abort);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', abort);\n      }\n\n      emitter.removeAllListeners();\n    }\n\n    onDone((value, isRejected) => {\n      isDone = true;\n      if (isRejected) {\n        rejected = true;\n        onFinished();\n      }\n    });\n\n    function abort(reason) {\n      emitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);\n    }\n\n    emitter.once('abort', reject);\n\n    if (config.cancelToken || config.signal) {\n      config.cancelToken && config.cancelToken.subscribe(abort);\n      if (config.signal) {\n        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);\n      }\n    }\n\n    // Parse url\n    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);\n    const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : undefined);\n    const protocol = parsed.protocol || supportedProtocols[0];\n\n    if (protocol === 'data:') {\n      // Apply the same semantics as HTTP: only enforce if a finite, non-negative cap is set.\n      if (config.maxContentLength > -1) {\n        // Use the exact string passed to fromDataURI (config.url); fall back to fullPath if needed.\n        const dataUrl = String(config.url || fullPath || '');\n        const estimated = estimateDataURLDecodedBytes(dataUrl);\n\n        if (estimated > config.maxContentLength) {\n          return reject(new AxiosError(\n            'maxContentLength size of ' + config.maxContentLength + ' exceeded',\n            AxiosError.ERR_BAD_RESPONSE,\n            config\n          ));\n        }\n      }\n\n      let convertedData;\n\n      if (method !== 'GET') {\n        return settle(resolve, reject, {\n          status: 405,\n          statusText: 'method not allowed',\n          headers: {},\n          config\n        });\n      }\n\n      try {\n        convertedData = fromDataURI(config.url, responseType === 'blob', {\n          Blob: config.env && config.env.Blob\n        });\n      } catch (err) {\n        throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);\n      }\n\n      if (responseType === 'text') {\n        convertedData = convertedData.toString(responseEncoding);\n\n        if (!responseEncoding || responseEncoding === 'utf8') {\n          convertedData = utils.stripBOM(convertedData);\n        }\n      } else if (responseType === 'stream') {\n        convertedData = stream.Readable.from(convertedData);\n      }\n\n      return settle(resolve, reject, {\n        data: convertedData,\n        status: 200,\n        statusText: 'OK',\n        headers: new AxiosHeaders(),\n        config\n      });\n    }\n\n    if (supportedProtocols.indexOf(protocol) === -1) {\n      return reject(new AxiosError(\n        'Unsupported protocol ' + protocol,\n        AxiosError.ERR_BAD_REQUEST,\n        config\n      ));\n    }\n\n    const headers = AxiosHeaders.from(config.headers).normalize();\n\n    // Set User-Agent (required by some servers)\n    // See https://github.com/axios/axios/issues/69\n    // User-Agent is specified; handle case where no UA header is desired\n    // Only set header if it hasn't been set in config\n    headers.set('User-Agent', 'axios/' + VERSION, false);\n\n    const {onUploadProgress, onDownloadProgress} = config;\n    const maxRate = config.maxRate;\n    let maxUploadRate = undefined;\n    let maxDownloadRate = undefined;\n\n    // support for spec compliant FormData objects\n    if (utils.isSpecCompliantForm(data)) {\n      const userBoundary = headers.getContentType(/boundary=([-_\\w\\d]{10,70})/i);\n\n      data = formDataToStream(data, (formHeaders) => {\n        headers.set(formHeaders);\n      }, {\n        tag: `axios-${VERSION}-boundary`,\n        boundary: userBoundary && userBoundary[1] || undefined\n      });\n      // support for https://www.npmjs.com/package/form-data api\n    } else if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {\n      headers.set(data.getHeaders());\n\n      if (!headers.hasContentLength()) {\n        try {\n          const knownLength = await util.promisify(data.getLength).call(data);\n          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);\n          /*eslint no-empty:0*/\n        } catch (e) {\n        }\n      }\n    } else if (utils.isBlob(data) || utils.isFile(data)) {\n      data.size && headers.setContentType(data.type || 'application/octet-stream');\n      headers.setContentLength(data.size || 0);\n      data = stream.Readable.from(readBlob(data));\n    } else if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {\n        // Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = Buffer.from(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = Buffer.from(data, 'utf-8');\n      } else {\n        return reject(new AxiosError(\n          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',\n          AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n\n      // Add Content-Length header if data exists\n      headers.setContentLength(data.length, false);\n\n      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {\n        return reject(new AxiosError(\n          'Request body larger than maxBodyLength limit',\n          AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n    }\n\n    const contentLength = utils.toFiniteNumber(headers.getContentLength());\n\n    if (utils.isArray(maxRate)) {\n      maxUploadRate = maxRate[0];\n      maxDownloadRate = maxRate[1];\n    } else {\n      maxUploadRate = maxDownloadRate = maxRate;\n    }\n\n    if (data && (onUploadProgress || maxUploadRate)) {\n      if (!utils.isStream(data)) {\n        data = stream.Readable.from(data, {objectMode: false});\n      }\n\n      data = stream.pipeline([data, new AxiosTransformStream({\n        maxRate: utils.toFiniteNumber(maxUploadRate)\n      })], utils.noop);\n\n      onUploadProgress && data.on('progress', flushOnFinish(\n        data,\n        progressEventDecorator(\n          contentLength,\n          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)\n        )\n      ));\n    }\n\n    // HTTP basic authentication\n    let auth = undefined;\n    if (config.auth) {\n      const username = config.auth.username || '';\n      const password = config.auth.password || '';\n      auth = username + ':' + password;\n    }\n\n    if (!auth && parsed.username) {\n      const urlUsername = parsed.username;\n      const urlPassword = parsed.password;\n      auth = urlUsername + ':' + urlPassword;\n    }\n\n    auth && headers.delete('authorization');\n\n    let path;\n\n    try {\n      path = buildURL(\n        parsed.pathname + parsed.search,\n        config.params,\n        config.paramsSerializer\n      ).replace(/^\\?/, '');\n    } catch (err) {\n      const customErr = new Error(err.message);\n      customErr.config = config;\n      customErr.url = config.url;\n      customErr.exists = true;\n      return reject(customErr);\n    }\n\n    headers.set(\n      'Accept-Encoding',\n      'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''), false\n      );\n\n    const options = {\n      path,\n      method: method,\n      headers: headers.toJSON(),\n      agents: { http: config.httpAgent, https: config.httpsAgent },\n      auth,\n      protocol,\n      family,\n      beforeRedirect: dispatchBeforeRedirect,\n      beforeRedirects: {}\n    };\n\n    // cacheable-lookup integration hotfix\n    !utils.isUndefined(lookup) && (options.lookup = lookup);\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname.startsWith(\"[\") ? parsed.hostname.slice(1, -1) : parsed.hostname;\n      options.port = parsed.port;\n      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);\n    }\n\n    let transport;\n    const isHttpsRequest = isHttps.test(options.protocol);\n    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n    if (config.transport) {\n      transport = config.transport;\n    } else if (config.maxRedirects === 0) {\n      transport = isHttpsRequest ? https : http;\n    } else {\n      if (config.maxRedirects) {\n        options.maxRedirects = config.maxRedirects;\n      }\n      if (config.beforeRedirect) {\n        options.beforeRedirects.config = config.beforeRedirect;\n      }\n      transport = isHttpsRequest ? httpsFollow : httpFollow;\n    }\n\n    if (config.maxBodyLength > -1) {\n      options.maxBodyLength = config.maxBodyLength;\n    } else {\n      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited\n      options.maxBodyLength = Infinity;\n    }\n\n    if (config.insecureHTTPParser) {\n      options.insecureHTTPParser = config.insecureHTTPParser;\n    }\n\n    // Create the request\n    req = transport.request(options, function handleResponse(res) {\n      if (req.destroyed) return;\n\n      const streams = [res];\n\n      const responseLength = +res.headers['content-length'];\n\n      if (onDownloadProgress || maxDownloadRate) {\n        const transformStream = new AxiosTransformStream({\n          maxRate: utils.toFiniteNumber(maxDownloadRate)\n        });\n\n        onDownloadProgress && transformStream.on('progress', flushOnFinish(\n          transformStream,\n          progressEventDecorator(\n            responseLength,\n            progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)\n          )\n        ));\n\n        streams.push(transformStream);\n      }\n\n      // decompress the response body transparently if required\n      let responseStream = res;\n\n      // return the last request in case of redirects\n      const lastRequest = res.req || req;\n\n      // if decompress disabled we should not decompress\n      if (config.decompress !== false && res.headers['content-encoding']) {\n        // if no content, but headers still say that it is encoded,\n        // remove the header not confuse downstream operations\n        if (method === 'HEAD' || res.statusCode === 204) {\n          delete res.headers['content-encoding'];\n        }\n\n        switch ((res.headers['content-encoding'] || '').toLowerCase()) {\n        /*eslint default-case:0*/\n        case 'gzip':\n        case 'x-gzip':\n        case 'compress':\n        case 'x-compress':\n          // add the unzipper to the body stream processing pipeline\n          streams.push(zlib.createUnzip(zlibOptions));\n\n          // remove the content-encoding in order to not confuse downstream operations\n          delete res.headers['content-encoding'];\n          break;\n        case 'deflate':\n          streams.push(new ZlibHeaderTransformStream());\n\n          // add the unzipper to the body stream processing pipeline\n          streams.push(zlib.createUnzip(zlibOptions));\n\n          // remove the content-encoding in order to not confuse downstream operations\n          delete res.headers['content-encoding'];\n          break;\n        case 'br':\n          if (isBrotliSupported) {\n            streams.push(zlib.createBrotliDecompress(brotliOptions));\n            delete res.headers['content-encoding'];\n          }\n        }\n      }\n\n      responseStream = streams.length > 1 ? stream.pipeline(streams, utils.noop) : streams[0];\n\n      const offListeners = stream.finished(responseStream, () => {\n        offListeners();\n        onFinished();\n      });\n\n      const response = {\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: new AxiosHeaders(res.headers),\n        config,\n        request: lastRequest\n      };\n\n      if (responseType === 'stream') {\n        response.data = responseStream;\n        settle(resolve, reject, response);\n      } else {\n        const responseBuffer = [];\n        let totalResponseBytes = 0;\n\n        responseStream.on('data', function handleStreamData(chunk) {\n          responseBuffer.push(chunk);\n          totalResponseBytes += chunk.length;\n\n          // make sure the content length is not over the maxContentLength if specified\n          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {\n            // stream.destroy() emit aborted event before calling reject() on Node.js v16\n            rejected = true;\n            responseStream.destroy();\n            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',\n              AxiosError.ERR_BAD_RESPONSE, config, lastRequest));\n          }\n        });\n\n        responseStream.on('aborted', function handlerStreamAborted() {\n          if (rejected) {\n            return;\n          }\n\n          const err = new AxiosError(\n            'stream has been aborted',\n            AxiosError.ERR_BAD_RESPONSE,\n            config,\n            lastRequest\n          );\n          responseStream.destroy(err);\n          reject(err);\n        });\n\n        responseStream.on('error', function handleStreamError(err) {\n          if (req.destroyed) return;\n          reject(AxiosError.from(err, null, config, lastRequest));\n        });\n\n        responseStream.on('end', function handleStreamEnd() {\n          try {\n            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);\n            if (responseType !== 'arraybuffer') {\n              responseData = responseData.toString(responseEncoding);\n              if (!responseEncoding || responseEncoding === 'utf8') {\n                responseData = utils.stripBOM(responseData);\n              }\n            }\n            response.data = responseData;\n          } catch (err) {\n            return reject(AxiosError.from(err, null, config, response.request, response));\n          }\n          settle(resolve, reject, response);\n        });\n      }\n\n      emitter.once('abort', err => {\n        if (!responseStream.destroyed) {\n          responseStream.emit('error', err);\n          responseStream.destroy();\n        }\n      });\n    });\n\n    emitter.once('abort', err => {\n      reject(err);\n      req.destroy(err);\n    });\n\n    // Handle errors\n    req.on('error', function handleRequestError(err) {\n      // @todo remove\n      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;\n      reject(AxiosError.from(err, null, config, req));\n    });\n\n    // set tcp keep alive to prevent drop connection by peer\n    req.on('socket', function handleRequestSocket(socket) {\n      // default interval of sending ack packet is 1 minute\n      socket.setKeepAlive(true, 1000 * 60);\n    });\n\n    // Handle request timeout\n    if (config.timeout) {\n      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.\n      const timeout = parseInt(config.timeout, 10);\n\n      if (Number.isNaN(timeout)) {\n        reject(new AxiosError(\n          'error trying to parse `config.timeout` to int',\n          AxiosError.ERR_BAD_OPTION_VALUE,\n          config,\n          req\n        ));\n\n        return;\n      }\n\n      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n      // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n      // And then these socket which be hang up will devouring CPU little by little.\n      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n      req.setTimeout(timeout, function handleRequestTimeout() {\n        if (isDone) return;\n        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n        const transitional = config.transitional || transitionalDefaults;\n        if (config.timeoutErrorMessage) {\n          timeoutErrorMessage = config.timeoutErrorMessage;\n        }\n        reject(new AxiosError(\n          timeoutErrorMessage,\n          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n          config,\n          req\n        ));\n        abort();\n      });\n    }\n\n\n    // Send the request\n    if (utils.isStream(data)) {\n      let ended = false;\n      let errored = false;\n\n      data.on('end', () => {\n        ended = true;\n      });\n\n      data.once('error', err => {\n        errored = true;\n        req.destroy(err);\n      });\n\n      data.on('close', () => {\n        if (!ended && !errored) {\n          abort(new CanceledError('Request stream has been aborted', config, req));\n        }\n      });\n\n      data.pipe(req);\n    } else {\n      req.end(data);\n    }\n  });\n}\n\nexport const __setProxy = setProxy;\n"],"names":["zlibOptions","flush","zlib","constants","Z_SYNC_FLUSH","finishFlush","brotliOptions","BROTLI_OPERATION_FLUSH","isBrotliSupported","utils","isFunction","createBrotliDecompress","http","httpFollow","https","httpsFollow","followRedirects","isHttps","supportedProtocols","platform","protocols","map","protocol","flushOnFinish","stream","throttled","on","dispatchBeforeRedirect","options","responseDetails","beforeRedirects","proxy","config","setProxy","configProxy","location","proxyUrl","proxyFromEnv","getProxyForUrl","URL","username","auth","password","base64","Buffer","from","toString","headers","host","hostname","port","proxyHost","path","includes","redirectOptions","href","isHttpAdapterSupported","process","kindOf","buildAddressEntry","address","family","isString","TypeError","indexOf","resolveFamily","isObject","httpAdapter","asyncExecutor","async","resolve","reject","onDone","data","lookup","responseType","responseEncoding","method","toUpperCase","isDone","req","rejected","_lookup","callbackify","value","isArray","opt","cb","err","arg0","arg1","addresses","addr","all","emitter","EventEmitter","onFinished","cancelToken","unsubscribe","abort","signal","removeEventListener","removeAllListeners","reason","emit","type","CanceledError","isRejected","once","subscribe","aborted","addEventListener","fullPath","buildFullPath","baseURL","url","allowAbsoluteUrls","parsed","hasBrowserEnv","origin","undefined","maxContentLength","dataUrl","String","estimateDataURLDecodedBytes","AxiosError","ERR_BAD_RESPONSE","convertedData","settle","status","statusText","fromDataURI","Blob","env","ERR_BAD_REQUEST","stripBOM","Readable","AxiosHeaders","normalize","set","VERSION","onUploadProgress","onDownloadProgress","maxRate","maxUploadRate","maxDownloadRate","isSpecCompliantForm","userBoundary","getContentType","formDataToStream","formHeaders","tag","boundary","isFormData","getHeaders","hasContentLength","knownLength","util","promisify","getLength","call","Number","isFinite","setContentLength","e","isBlob","isFile","size","setContentType","readBlob","isStream","isBuffer","isArrayBuffer","Uint8Array","length","maxBodyLength","contentLength","toFiniteNumber","getContentLength","objectMode","pipeline","AxiosTransformStream","noop","progressEventDecorator","progressEventReducer","asyncDecorator","delete","buildURL","pathname","search","params","paramsSerializer","replace","customErr","Error","message","exists","toJSON","agents","httpAgent","httpsAgent","beforeRedirect","transport","isUndefined","socketPath","startsWith","slice","isHttpsRequest","test","agent","maxRedirects","Infinity","insecureHTTPParser","request","res","destroyed","streams","responseLength","transformStream","push","responseStream","lastRequest","decompress","statusCode","toLowerCase","createUnzip","ZlibHeaderTransformStream","offListeners","finished","response","statusMessage","responseBuffer","totalResponseBytes","chunk","destroy","responseData","concat","socket","setKeepAlive","timeout","parseInt","isNaN","ERR_BAD_OPTION_VALUE","setTimeout","timeoutErrorMessage","transitional","transitionalDefaults","clarifyTimeoutError","ETIMEDOUT","ECONNABORTED","ended","errored","pipe","end","Promise","done","_reject","onDoneHandler","catch"],"mappings":"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"}