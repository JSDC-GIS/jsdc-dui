{"version":3,"file":"AxiosHeaders.js","sources":["../../../../../node_modules/axios/lib/core/AxiosHeaders.js"],"sourcesContent":["'use strict';\n\nimport utils from '../utils.js';\nimport parseHeaders from '../helpers/parseHeaders.js';\n\nconst $internals = Symbol('internals');\n\nfunction normalizeHeader(header) {\n  return header && String(header).trim().toLowerCase();\n}\n\nfunction normalizeValue(value) {\n  if (value === false || value == null) {\n    return value;\n  }\n\n  return utils.isArray(value) ? value.map(normalizeValue) : String(value);\n}\n\nfunction parseTokens(str) {\n  const tokens = Object.create(null);\n  const tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  let match;\n\n  while ((match = tokensRE.exec(str))) {\n    tokens[match[1]] = match[2];\n  }\n\n  return tokens;\n}\n\nconst isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());\n\nfunction matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {\n  if (utils.isFunction(filter)) {\n    return filter.call(this, value, header);\n  }\n\n  if (isHeaderNameFilter) {\n    value = header;\n  }\n\n  if (!utils.isString(value)) return;\n\n  if (utils.isString(filter)) {\n    return value.indexOf(filter) !== -1;\n  }\n\n  if (utils.isRegExp(filter)) {\n    return filter.test(value);\n  }\n}\n\nfunction formatHeader(header) {\n  return header.trim()\n    .toLowerCase().replace(/([a-z\\d])(\\w*)/g, (w, char, str) => {\n      return char.toUpperCase() + str;\n    });\n}\n\nfunction buildAccessors(obj, header) {\n  const accessorName = utils.toCamelCase(' ' + header);\n\n  ['get', 'set', 'has'].forEach(methodName => {\n    Object.defineProperty(obj, methodName + accessorName, {\n      value: function(arg1, arg2, arg3) {\n        return this[methodName].call(this, header, arg1, arg2, arg3);\n      },\n      configurable: true\n    });\n  });\n}\n\nclass AxiosHeaders {\n  constructor(headers) {\n    headers && this.set(headers);\n  }\n\n  set(header, valueOrRewrite, rewrite) {\n    const self = this;\n\n    function setHeader(_value, _header, _rewrite) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!lHeader) {\n        throw new Error('header name must be a non-empty string');\n      }\n\n      const key = utils.findKey(self, lHeader);\n\n      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {\n        self[key || _header] = normalizeValue(_value);\n      }\n    }\n\n    const setHeaders = (headers, _rewrite) =>\n      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));\n\n    if (utils.isPlainObject(header) || header instanceof this.constructor) {\n      setHeaders(header, valueOrRewrite)\n    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n      setHeaders(parseHeaders(header), valueOrRewrite);\n    } else if (utils.isObject(header) && utils.isIterable(header)) {\n      let obj = {}, dest, key;\n      for (const entry of header) {\n        if (!utils.isArray(entry)) {\n          throw TypeError('Object iterator must return a key-value pair');\n        }\n\n        obj[key = entry[0]] = (dest = obj[key]) ?\n          (utils.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]]) : entry[1];\n      }\n\n      setHeaders(obj, valueOrRewrite)\n    } else {\n      header != null && setHeader(valueOrRewrite, header, rewrite);\n    }\n\n    return this;\n  }\n\n  get(header, parser) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      if (key) {\n        const value = this[key];\n\n        if (!parser) {\n          return value;\n        }\n\n        if (parser === true) {\n          return parseTokens(value);\n        }\n\n        if (utils.isFunction(parser)) {\n          return parser.call(this, value, key);\n        }\n\n        if (utils.isRegExp(parser)) {\n          return parser.exec(value);\n        }\n\n        throw new TypeError('parser must be boolean|regexp|function');\n      }\n    }\n  }\n\n  has(header, matcher) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n    }\n\n    return false;\n  }\n\n  delete(header, matcher) {\n    const self = this;\n    let deleted = false;\n\n    function deleteHeader(_header) {\n      _header = normalizeHeader(_header);\n\n      if (_header) {\n        const key = utils.findKey(self, _header);\n\n        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n          delete self[key];\n\n          deleted = true;\n        }\n      }\n    }\n\n    if (utils.isArray(header)) {\n      header.forEach(deleteHeader);\n    } else {\n      deleteHeader(header);\n    }\n\n    return deleted;\n  }\n\n  clear(matcher) {\n    const keys = Object.keys(this);\n    let i = keys.length;\n    let deleted = false;\n\n    while (i--) {\n      const key = keys[i];\n      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {\n        delete this[key];\n        deleted = true;\n      }\n    }\n\n    return deleted;\n  }\n\n  normalize(format) {\n    const self = this;\n    const headers = {};\n\n    utils.forEach(this, (value, header) => {\n      const key = utils.findKey(headers, header);\n\n      if (key) {\n        self[key] = normalizeValue(value);\n        delete self[header];\n        return;\n      }\n\n      const normalized = format ? formatHeader(header) : String(header).trim();\n\n      if (normalized !== header) {\n        delete self[header];\n      }\n\n      self[normalized] = normalizeValue(value);\n\n      headers[normalized] = true;\n    });\n\n    return this;\n  }\n\n  concat(...targets) {\n    return this.constructor.concat(this, ...targets);\n  }\n\n  toJSON(asStrings) {\n    const obj = Object.create(null);\n\n    utils.forEach(this, (value, header) => {\n      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);\n    });\n\n    return obj;\n  }\n\n  [Symbol.iterator]() {\n    return Object.entries(this.toJSON())[Symbol.iterator]();\n  }\n\n  toString() {\n    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\\n');\n  }\n\n  getSetCookie() {\n    return this.get(\"set-cookie\") || [];\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'AxiosHeaders';\n  }\n\n  static from(thing) {\n    return thing instanceof this ? thing : new this(thing);\n  }\n\n  static concat(first, ...targets) {\n    const computed = new this(first);\n\n    targets.forEach((target) => computed.set(target));\n\n    return computed;\n  }\n\n  static accessor(header) {\n    const internals = this[$internals] = (this[$internals] = {\n      accessors: {}\n    });\n\n    const accessors = internals.accessors;\n    const prototype = this.prototype;\n\n    function defineAccessor(_header) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!accessors[lHeader]) {\n        buildAccessors(prototype, _header);\n        accessors[lHeader] = true;\n      }\n    }\n\n    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n\n    return this;\n  }\n}\n\nAxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);\n\n// reserved names hotfix\nutils.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {\n  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`\n  return {\n    get: () => value,\n    set(headerValue) {\n      this[mapped] = headerValue;\n    }\n  }\n});\n\nutils.freezeMethods(AxiosHeaders);\n\nexport default AxiosHeaders;\n"],"names":["$internals","Symbol","normalizeHeader","header","String","trim","toLowerCase","normalizeValue","value","utils","isArray","map","matchHeaderValue","context","filter","isHeaderNameFilter","isFunction","call","this","isString","indexOf","isRegExp","test","AxiosHeaders","constructor","headers","set","valueOrRewrite","rewrite","self","setHeader","_value","_header","_rewrite","lHeader","Error","key","findKey","undefined","setHeaders","forEach","isPlainObject","parseHeaders","isObject","isIterable","dest","obj","entry","TypeError","get","parser","str","tokens","Object","create","tokensRE","match","exec","parseTokens","has","matcher","delete","deleted","deleteHeader","clear","keys","i","length","normalize","format","normalized","replace","w","char","toUpperCase","formatHeader","concat","targets","toJSON","asStrings","join","iterator","entries","toString","getSetCookie","toStringTag","static","thing","first","computed","target","accessors","prototype","defineAccessor","accessorName","toCamelCase","methodName","defineProperty","arg1","arg2","arg3","configurable","buildAccessors","accessor","reduceDescriptors","mapped","slice","headerValue","freezeMethods","AxiosHeaders$1"],"mappings":"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"}