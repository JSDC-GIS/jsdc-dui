import t from"../utils.js";import e from"../helpers/parseHeaders.js";const r=Symbol("internals");function s(t){return t&&String(t).trim().toLowerCase()}function n(e){return!1===e||null==e?e:t.isArray(e)?e.map(n):String(e)}function i(e,r,s,n,i){return t.isFunction(n)?n.call(this,r,s):(i&&(r=s),t.isString(r)?t.isString(n)?-1!==r.indexOf(n):t.isRegExp(n)?n.test(r):void 0:void 0)}class o{constructor(t){t&&this.set(t)}set(r,i,o){const c=this;function a(e,r,i){const o=s(r);if(!o)throw new Error("header name must be a non-empty string");const a=t.findKey(c,o);(!a||void 0===c[a]||!0===i||void 0===i&&!1!==c[a])&&(c[a||r]=n(e))}const u=(e,r)=>t.forEach(e,((t,e)=>a(t,e,r)));if(t.isPlainObject(r)||r instanceof this.constructor)u(r,i);else if(t.isString(r)&&(r=r.trim())&&!/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(r.trim()))u(e(r),i);else if(t.isObject(r)&&t.isIterable(r)){let e,s,n={};for(const i of r){if(!t.isArray(i))throw TypeError("Object iterator must return a key-value pair");n[s=i[0]]=(e=n[s])?t.isArray(e)?[...e,i[1]]:[e,i[1]]:i[1]}u(n,i)}else null!=r&&a(i,r,o);return this}get(e,r){if(e=s(e)){const s=t.findKey(this,e);if(s){const e=this[s];if(!r)return e;if(!0===r)return function(t){const e=Object.create(null),r=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let s;for(;s=r.exec(t);)e[s[1]]=s[2];return e}(e);if(t.isFunction(r))return r.call(this,e,s);if(t.isRegExp(r))return r.exec(e);throw new TypeError("parser must be boolean|regexp|function")}}}has(e,r){if(e=s(e)){const s=t.findKey(this,e);return!(!s||void 0===this[s]||r&&!i(0,this[s],s,r))}return!1}delete(e,r){const n=this;let o=!1;function c(e){if(e=s(e)){const s=t.findKey(n,e);!s||r&&!i(0,n[s],s,r)||(delete n[s],o=!0)}}return t.isArray(e)?e.forEach(c):c(e),o}clear(t){const e=Object.keys(this);let r=e.length,s=!1;for(;r--;){const n=e[r];t&&!i(0,this[n],n,t,!0)||(delete this[n],s=!0)}return s}normalize(e){const r=this,s={};return t.forEach(this,((i,o)=>{const c=t.findKey(s,o);if(c)return r[c]=n(i),void delete r[o];const a=e?function(t){return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,((t,e,r)=>e.toUpperCase()+r))}(o):String(o).trim();a!==o&&delete r[o],r[a]=n(i),s[a]=!0})),this}concat(...t){return this.constructor.concat(this,...t)}toJSON(e){const r=Object.create(null);return t.forEach(this,((s,n)=>{null!=s&&!1!==s&&(r[n]=e&&t.isArray(s)?s.join(", "):s)})),r}[Symbol.iterator](){return Object.entries(this.toJSON())[Symbol.iterator]()}toString(){return Object.entries(this.toJSON()).map((([t,e])=>t+": "+e)).join("\n")}getSetCookie(){return this.get("set-cookie")||[]}get[Symbol.toStringTag](){return"AxiosHeaders"}static from(t){return t instanceof this?t:new this(t)}static concat(t,...e){const r=new this(t);return e.forEach((t=>r.set(t))),r}static accessor(e){const n=(this[r]=this[r]={accessors:{}}).accessors,i=this.prototype;function o(e){const r=s(e);n[r]||(!function(e,r){const s=t.toCamelCase(" "+r);["get","set","has"].forEach((t=>{Object.defineProperty(e,t+s,{value:function(e,s,n){return this[t].call(this,r,e,s,n)},configurable:!0})}))}(i,e),n[r]=!0)}return t.isArray(e)?e.forEach(o):o(e),this}}o.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]),t.reduceDescriptors(o.prototype,(({value:t},e)=>{let r=e[0].toUpperCase()+e.slice(1);return{get:()=>t,set(t){this[r]=t}}})),t.freezeMethods(o);var c=o;export{c as default};
//# sourceMappingURL=AxiosHeaders.js.map
