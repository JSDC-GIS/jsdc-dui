{"version":3,"file":"mergeConfig.js","sources":["../../../../../node_modules/axios/lib/core/mergeConfig.js"],"sourcesContent":["'use strict';\n\nimport utils from '../utils.js';\nimport AxiosHeaders from \"./AxiosHeaders.js\";\n\nconst headersToObject = (thing) => thing instanceof AxiosHeaders ? { ...thing } : thing;\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n *\n * @returns {Object} New object resulting from merging config2 to config1\n */\nexport default function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  const config = {};\n\n  function getMergedValue(target, source, prop, caseless) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge.call({caseless}, target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(a, b, prop , caseless) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(a, b, prop , caseless);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a, prop , caseless);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(a, b, prop) {\n    if (prop in config2) {\n      return getMergedValue(a, b);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  const mergeMap = {\n    url: valueFromConfig2,\n    method: valueFromConfig2,\n    data: valueFromConfig2,\n    baseURL: defaultToConfig2,\n    transformRequest: defaultToConfig2,\n    transformResponse: defaultToConfig2,\n    paramsSerializer: defaultToConfig2,\n    timeout: defaultToConfig2,\n    timeoutMessage: defaultToConfig2,\n    withCredentials: defaultToConfig2,\n    withXSRFToken: defaultToConfig2,\n    adapter: defaultToConfig2,\n    responseType: defaultToConfig2,\n    xsrfCookieName: defaultToConfig2,\n    xsrfHeaderName: defaultToConfig2,\n    onUploadProgress: defaultToConfig2,\n    onDownloadProgress: defaultToConfig2,\n    decompress: defaultToConfig2,\n    maxContentLength: defaultToConfig2,\n    maxBodyLength: defaultToConfig2,\n    beforeRedirect: defaultToConfig2,\n    transport: defaultToConfig2,\n    httpAgent: defaultToConfig2,\n    httpsAgent: defaultToConfig2,\n    cancelToken: defaultToConfig2,\n    socketPath: defaultToConfig2,\n    responseEncoding: defaultToConfig2,\n    validateStatus: mergeDirectKeys,\n    headers: (a, b , prop) => mergeDeepProperties(headersToObject(a), headersToObject(b),prop, true)\n  };\n\n  utils.forEach(Object.keys({...config1, ...config2}), function computeConfigValue(prop) {\n    const merge = mergeMap[prop] || mergeDeepProperties;\n    const configValue = merge(config1[prop], config2[prop], prop);\n    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n}\n"],"names":["headersToObject","thing","AxiosHeaders","mergeConfig","config1","config2","config","getMergedValue","target","source","prop","caseless","utils","isPlainObject","merge","call","isArray","slice","mergeDeepProperties","a","b","isUndefined","undefined","valueFromConfig2","defaultToConfig2","mergeDirectKeys","mergeMap","url","method","data","baseURL","transformRequest","transformResponse","paramsSerializer","timeout","timeoutMessage","withCredentials","withXSRFToken","adapter","responseType","xsrfCookieName","xsrfHeaderName","onUploadProgress","onDownloadProgress","decompress","maxContentLength","maxBodyLength","beforeRedirect","transport","httpAgent","httpsAgent","cancelToken","socketPath","responseEncoding","validateStatus","headers","forEach","Object","keys","configValue"],"mappings":"4DAKA,MAAMA,EAAmBC,GAAUA,aAAiBC,EAAe,IAAKD,GAAUA,EAWnE,SAASE,EAAYC,EAASC,GAE3CA,EAAUA,GAAW,GACrB,MAAMC,EAAS,GAEf,SAASC,EAAeC,EAAQC,EAAQC,EAAMC,GAC5C,OAAIC,EAAMC,cAAcL,IAAWI,EAAMC,cAAcJ,GAC9CG,EAAME,MAAMC,KAAK,CAACJ,SAAAA,GAAWH,EAAQC,GACnCG,EAAMC,cAAcJ,GACtBG,EAAME,MAAM,GAAIL,GACdG,EAAMI,QAAQP,GAChBA,EAAOQ,QAETR,EAIT,SAASS,EAAoBC,EAAGC,EAAGV,EAAOC,GACxC,OAAKC,EAAMS,YAAYD,GAEXR,EAAMS,YAAYF,QAAvB,EACEZ,OAAee,EAAWH,EAAGT,EAAOC,GAFpCJ,EAAeY,EAAGC,EAAGV,EAAOC,GAOvC,SAASY,EAAiBJ,EAAGC,GAC3B,IAAKR,EAAMS,YAAYD,GACrB,OAAOb,OAAee,EAAWF,GAKrC,SAASI,EAAiBL,EAAGC,GAC3B,OAAKR,EAAMS,YAAYD,GAEXR,EAAMS,YAAYF,QAAvB,EACEZ,OAAee,EAAWH,GAF1BZ,OAAee,EAAWF,GAOrC,SAASK,EAAgBN,EAAGC,EAAGV,GAC7B,OAAIA,KAAQL,EACHE,EAAeY,EAAGC,GAChBV,KAAQN,EACVG,OAAee,EAAWH,QAD5B,EAKT,MAAMO,EAAW,CACfC,IAAKJ,EACLK,OAAQL,EACRM,KAAMN,EACNO,QAASN,EACTO,iBAAkBP,EAClBQ,kBAAmBR,EACnBS,iBAAkBT,EAClBU,QAASV,EACTW,eAAgBX,EAChBY,gBAAiBZ,EACjBa,cAAeb,EACfc,QAASd,EACTe,aAAcf,EACdgB,eAAgBhB,EAChBiB,eAAgBjB,EAChBkB,iBAAkBlB,EAClBmB,mBAAoBnB,EACpBoB,WAAYpB,EACZqB,iBAAkBrB,EAClBsB,cAAetB,EACfuB,eAAgBvB,EAChBwB,UAAWxB,EACXyB,UAAWzB,EACX0B,WAAY1B,EACZ2B,YAAa3B,EACb4B,WAAY5B,EACZ6B,iBAAkB7B,EAClB8B,eAAgB7B,EAChB8B,QAAS,CAACpC,EAAGC,EAAIV,IAASQ,EAAoBlB,EAAgBmB,GAAInB,EAAgBoB,GAAGV,GAAM,IAS7F,OANAE,EAAM4C,QAAQC,OAAOC,KAAK,IAAItD,KAAYC,KAAW,SAA4BK,GAC/E,MAAMI,EAAQY,EAAShB,IAASQ,EAC1ByC,EAAc7C,EAAMV,EAAQM,GAAOL,EAAQK,GAAOA,GACvDE,EAAMS,YAAYsC,IAAgB7C,IAAUW,IAAqBnB,EAAOI,GAAQiD,MAG5ErD"}